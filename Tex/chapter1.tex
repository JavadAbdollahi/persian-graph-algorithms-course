\chapter{تکنیک‌های اولیه پیمایش گراف}
\label{chap:traversal}

پس از آشنایی با تعاریف رسمی گراف در فصل قبل، در این فصل به سراغ دو روش بنیادین برای پیمایش رئوس و یال‌های گراف می‌رویم: جستجوی اول سطح (\lr{BFS}) و جستجوی اول عمق (\lr{DFS}). این الگوریتم‌ها سنگ بنای بسیاری از الگوریتم‌های پیشرفته‌تر گراف هستند. ما در این بخش، این الگوریتم‌ها را عمدتاً روی \textbf{گراف‌های ساده} توضیح می‌دهیم، اما منطق آن‌ها با استفاده از نمایش \textbf{لیست مجاورت} (\lr{Adjacency List}) (بخش \ref{def:adj_list})، برای گراف‌های دارای یال موازی نیز قابل تعمیم است.

\section{جستجوی اول سطح (\lr{Breadth-First Search - BFS})}
\label{sec:bfs}

الگوریتم جستجوی اول سطح (\lr{BFS}) یکی از ساده‌ترین و در عین حال پرکاربردترین الگوریتم‌های پیمایش گراف است. ایده اصلی این الگوریتم، شروع از یک رأس مبدأ و کاوش گراف به صورت لایه به لایه است.

\subsection{توضیح الگوریتم}
الگوریتم \lr{BFS} از یک رأس مشخص (مبدأ یا \lr{s}) شروع به پیمایش می‌کند و فرض می‌کند گراف با یک نمایش مناسب مانند \textbf{لیست مجاورت} (\lr{Adjacency List}) داده شده است. الگوریتم ابتدا تمام همسایه‌های مستقیم رأس \lr{s} را ملاقات می‌کند (لایه اول) و این روند را تا زمانی که تمام رئوس قابل دسترس از \lr{s} ملاقات شوند، ادامه می‌دهد. برای پیاده‌سازی این رفتار "لایه به لایه"، الگوریتم از یک \textbf{صف} (\lr{Queue}) (بخش \ref{def:queue}) استفاده می‌کند.

\subsection{شبه‌کد الگوریتم}
\begin{algorithm}[H]
	\caption{Breadth-First Search (BFS)}
	\label{alg:bfs}
	\begin{pseudocode}
		\Procedure{BFS}{$G, s$}
		\State Let $Q$ be a queue
		\State $Q$.enqueue($s$)
		\State Mark $s$ as visited
		\While{$Q$ is not empty}
		\State $u \gets Q$.dequeue()
		\State Process $u$ (e.g., print it)
		\For{each neighbor $v$ of $u$}
		\If{$v$ has not been visited}
		\State Mark $v$ as visited
		\State $Q$.enqueue($v$)
		\EndIf
		\EndFor
		\EndWhile
		\EndProcedure
	\end{pseudocode}
\end{algorithm}

\subsection{مثال}
یک گراف ساده و بدون جهت مانند شکل \ref{fig:bfs_example_graph} را در نظر بگیرید. می‌خواهیم پیمایش \lr{BFS} را از رأس \lr{A} شروع کنیم.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[
		node distance=1.5cm and 2.5cm,
		every node/.style={draw, circle, thick, font=\sffamily\Large}
		]
		\node (A) {A};
		\node (B) [below left=of A] {B};
		\node (C) [below right=of A] {C};
		\node (D) [below=of B] {D};
		\node (E) [below=of C] {E};
		\path[-, thick]
		(A) edge (B) (A) edge (C) (B) edge (D) (C) edge (E);
	\end{tikzpicture}
	\caption{یک گراف ساده و بدون جهت برای پیمایش \lr{BFS} از رأس \lr{A}.}
	\label{fig:bfs_example_graph}
\end{figure}
ترتیب ملاقات رئوس: \textbf{\lr{A, B, C, D, E}}.

\subsection{انیمیشن و ابزارهای پایتون}
\begin{itemize}
	\item \textbf{انیمیشن آنلاین:} برای درک شهودی، انیمیشن‌های تعاملی روند اجرای \lr{BFS} را در وب‌سایت \href{https://visualgo.net/en/dfsbfs}{Visualgo} مشاهده کنید.
	\item \textbf{اسکریپت پایتون تعاملی:} در کنار این جزوه، فایلی به نام \lr{bfs\_animation.py} قرار دارد. با اجرای این اسکریپت، می‌توانید روند اجرای الگوریتم \lr{BFS} را روی یک گراف نمونه به صورت یک انیمیشن مشاهده کنید. این اسکریپت از کتابخانه‌های \lr{\texttt{networkx}} برای منطق گراف و \lr{\texttt{matplotlib}} برای تولید انیمیشن استفاده می‌کند.
\end{itemize}